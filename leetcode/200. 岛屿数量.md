# 200. 岛屿数量

### 初次提交
```
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int size = grid.size();
        int res = 0;
        for (int i = 0; i < size; i++) {
            vector<char> cv = grid[i];
            for (int j = 0; j < cv.size(); j++) {
                // 深度优先的递归搜索
                int count = deepFristSearch(grid, i, j);
                res += count;
            }
        }
        return res;
    }
    int deepFristSearch(vector<vector<char>>& grid, int i, int j) {
        if (i < 0 || i > grid.size() - 1) {
            return 0;
        }
        if (j < 0 || j > grid[i].size() - 1) {
            return 0;
        }
        char target = grid[i][j];
        if (target == '1') {
            grid[i][j] = '0';
            deepFristSearch(grid, i - 1, j);
            deepFristSearch(grid, i + 1, j);
            deepFristSearch(grid, i, j - 1);
            deepFristSearch(grid, i, j + 1);
            return 1;
        }
        return 0;
    }
};
```


### 提交结果

![image](https://github.com/user-attachments/assets/25001ef4-985f-491a-9144-09c939ba35b9)


### 分析

时间复杂度O(mn)，空间复杂度O(mn)，递归栈所占用空间。(mn为行列数量)
1. 考虑优化时间
2. 考虑将递归算法换为迭代算法


### 第二次提交

> 待补充
