# 207. 课程表

### 初次提交
```
struct Node {
    int inDegree = 0;
    vector<int> next;
};
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 判断是否存在环
        // 1. 构建图
        // 2. 遍历所有点
        // 3. 存在环则false
        // 4. 使用一个set存储可以完成的节点
        // 5. 如何判断存在环？
        // 拓扑排序
        // 1. 从入度为0的点出发
        // 2. 将其后续节点的入度减一
        // 3. 如果入度为0，则删除，加入队列
        unordered_map<int, Node> m;
        for (int i = 0; i < prerequisites.size(); i ++) {
            vector<int> v = prerequisites[i];
            int a = v[0];
            int b = v[1];
            auto it = m.find(b);
            if (it != m.end()) {
                it->second.next.push_back(a);
            } else {
                Node n{ 0, vector<int> {a} };
                m.insert({ b, n });
            }
            it = m.find(a);
            if (it != m.end()) {
                it->second.inDegree += 1;
            } else {
                Node n{ 1, vector<int>() };
                m.insert({ a, n });
            }
        }
        queue<pair<int, Node>> q;
        // 迭代m 找寻入度为0的点
        for (auto it = m.begin(); it != m.end();) {
            if (it->second.inDegree == 0) {
                q.push(*it);
                it = m.erase(it);
            } else {
                 it ++;
            }
        }
        while (!q.empty()) {
            auto [key, node] = q.front();
            q.pop();
            for (int nextKey : node.next) {
                auto it = m.find(nextKey);
                if (it != m.end()) {
                    it->second.inDegree -= 1;
                    if (it->second.inDegree == 0) {
                        q.push(*it);
                        m.erase(it);
                    }
                }
            }
        }
        return m.size() == 0;
    }
};
```

### 结果
![image](https://github.com/user-attachments/assets/418b7c37-101b-4387-91d2-3e610552c6e2)

### 分析

时间复杂度O(n + e)，空间复杂度O(n)，n表示顶点数量，e表示边的数量

