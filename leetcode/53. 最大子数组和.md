# 53. 最大子数组和

### 初次提交
```
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 前缀和 + 贪心算法
        vector<int> v;
        v.reserve(nums.size() + 1);
        int total = 0;
        for (auto num : nums) {
            total += num;
            v.push_back(total);
        }
        int minIndex = -1;
        int max = v[0];
        for (int i = 0; i < v.size(); i++) {
            if (minIndex != -1 && i != minIndex) {
                int diff = v[i] - v[minIndex];
                max = std::max(diff, max);
            } else if (minIndex == -1) {
                max = std::max(v[i], max);
            }
            if (v[i] < 0 && minIndex == -1) {
                minIndex = i;
            }
            if (minIndex != -1 && v[i] < v[minIndex]) {
                minIndex = i;
            }
        }
        return max;
    }
};
```

### 结果
![image](https://github.com/user-attachments/assets/1920e70c-ef50-4ca6-b1a7-9f942a0c292c)


### 分析

时间复杂度O(n)，空间复杂度O(n)，代码需要整理的可读性更高，再尝试使用动态规划、分治法求解

### 二次提交 贪心算法
```
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 贪心算法 当前指针之前的元素和小于0，则丢弃之前的所有元素。
        int max = -10000;
        int preTotal = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (preTotal < 0) {
                preTotal = nums[i];
                max = std::max(max, nums[i]);
            } else {
                preTotal += nums[i];
                max = std::max(max, preTotal);
            }
        }
        return max;
    }
};
```

### 结果
![image](https://github.com/user-attachments/assets/f7939e8b-a9ba-451a-836b-5a6b0a28258e)

### 分析

时间复杂度O(n)，空间复杂度O(1)，贪心算法


### 三次提交 动态规划
```
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 动态规划 当前一个值大于0，则将其加到当前值
        int max = nums[0];
        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i - 1] > 0) {
                nums[i] += nums[i - 1];
            }
            max = std::max(max, nums[i]);
        }
        return max;
    }
};
```

### 结果
![image](https://github.com/user-attachments/assets/76450289-04ef-4601-a78d-d38efd65c529)

### 分析

时间复杂度 O(n)，空间复杂度O(1)，这就是动态规划的实力吗

### 四次提交 分治法

### 结果
