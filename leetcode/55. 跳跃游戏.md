# 55. 跳跃游戏

### 初次提交
```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        // 贪心算法：每次都跳到范围内最大的数字上 1.0
        // 贪心算法：每次都跳过0，然后到0之后的最大的数字上
        // 动态规划
        int targetIndex = nums.size() - 1;
        int currentIndex = 0;
        while (currentIndex < targetIndex) {
            if (nums[currentIndex] + currentIndex >= targetIndex) {
                return true;
            }
            if (nums[currentIndex] == 0) {
                return false;
            }
            int maxIndex = currentIndex + 1;
            int maxLength = min(currentIndex + nums[currentIndex], targetIndex);
            for (int i = currentIndex + 1; i <= maxLength; i ++) {
                if (nums[i] >= nums[maxIndex]) {
                    maxIndex = i;
                }
            }
            currentIndex = maxIndex;
        }
        return true;
    }
};
```

### 结果

失败

### 分析

贪心算法有点欠缺


### 二次提交

```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if (nums.size() <= 1) {
            return true;
        }
        // 回溯算法 会超时
        int targetIndex = nums.size() - 1;
        vector<int> s_index;
        s_index.push_back(0);
        while (!s_index.empty()) {
            int currentIndex = s_index.back();
            s_index.pop_back();
            int vectorLastIndex = s_index.size() == 0 ? 0 : s_index.size() - 1;
            int num = nums[currentIndex];
            if (currentIndex + num >= targetIndex) {
                return true;
            }
            int length = currentIndex + num;
            for (int i = length; i >= currentIndex + 1; i--) {
                s_index.push_back(i);
                if (i >= targetIndex) {
                    return true;
                }
            }
        }
        return false;
    }
};
```


### 结果

不通过
### 分析

不通过，回溯算法面对超长的无法通过的情况，会超时，会遍历每种情况

### 三次提交

动态规划
```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if (nums.size() < 2) {
            return true;
        }
        // 动态规划
        int minStep = 1;
        for (int i = nums.size() - 2; i > 0; i--) {
            if (nums[i] < minStep) {
                minStep ++;
            } else {
                minStep = 1;
            }
        }
        return nums[0] >= minStep;
    }
};
```

### 结果




### 分析

时间复杂度O(n)，空间复杂度O(1)
